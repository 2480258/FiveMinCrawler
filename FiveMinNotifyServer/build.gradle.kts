// Copied from https://github.com/twatzl/pf4j-kotlin-demo/blob/master/plugins/build.gradle.kts

import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.jetbrains.kotlin.kapt3.base.Kapt.kapt

plugins {
    id("org.springframework.boot") version "3.0.4"
    id("io.spring.dependency-management") version "1.1.0"
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring") version "1.7.22"
}

java.sourceCompatibility = JavaVersion.VERSION_17

repositories {
    mavenCentral()
}

tasks.bootJar {
    enabled = false
}

tasks.jar {
    enabled = true
}

dependencies {
    // shared libraries with root project
    compileOnly(rootProject)
    compileOnly(kotlin("stdlib"))
    compileOnly("io.arrow-kt:arrow-core:1.1.2")
    compileOnly("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4")
    compileOnly("org.pf4j:pf4j:3.8.0")
    
    implementation("org.springframework.boot:spring-boot-starter-websocket")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:1.6.4")
    
    testImplementation(rootProject)
    testImplementation("io.mockk:mockk:1.13.2")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.testng:testng:7.1.0")
    
    kapt("org.pf4j:pf4j:3.8.0")
}

tasks.withType<KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = listOf("-Xjsr305=strict")
        jvmTarget = "17"
    }
}

tasks.withType<Test> {
    useTestNG()
}


val pluginsDir = "${rootProject.projectDir.absolutePath}/plugins"
val project = this
// we have to apply the gradle jvm plugin, because it provides the jar and build tasks
apply(plugin = "org.jetbrains.kotlin.jvm")

// the plugin task will put the files into a zip file
tasks.register<Jar>("plugin") {
    manifest {
        attributes["Plugin-Class"] = project.properties["pluginClass"]
        attributes["Plugin-Id"] = project.properties["pluginId"]
        attributes["Plugin-Version"] = archiveVersion
        attributes["Plugin-Provider"] = project.properties["pluginProvider"]
    }
    
    archiveBaseName.set("plugin-${project.properties["pluginId"]}")
    
    // first taking the classes generated by the jar task
    into("classes") {
        with(tasks.named<Jar>("jar").get())
    }
    // and then we also need to include any libraries that are needed by the plugin
    dependsOn(configurations.runtimeClasspath)
    into("lib") {
        from({
            configurations.runtimeClasspath.get().filter { it.name.endsWith("jar") }
        })
    }
    archiveExtension.set("zip")
}

// the assemblePlugin will copy the zip file into the common plugins directory
tasks.register<Copy>("assemblePlugin") {
    from(project.tasks.named("plugin"))
    into(pluginsDir)
}

// for the jar task we have to set the plugin properties, so they can be written to the manifest
tasks.named<Jar>("jar") {
    manifest {
        attributes["Plugin-Class"] = project.properties["pluginClass"]
        attributes["Plugin-Id"] = project.properties["pluginId"]
        attributes["Plugin-Version"] = archiveVersion
        attributes["Plugin-Provider"] = project.properties["pluginProvider"]
    }
}

tasks.named("build") {
    dependsOn(tasks.named("plugin"))
}